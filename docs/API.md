# Packer's Assistant - API Reference

**Version:** 1.3.0.0
**Last Updated:** 2026-01-22
**Phase:** Phase 3.1 Complete - Session Browser & Performance Optimizations

---

## Table of Contents

### Core Business Logic
- [PackerLogic](#packerlogic) - Order processing and barcode generation
- [SessionManager](#sessionmanager) - Session lifecycle management
- [ProfileManager](#profilemanager) - Client profile management
- [StatisticsManager](#statisticsmanager) - Analytics and metrics tracking

### Data Management
- [SessionLockManager](#sessionlockmanager) - Multi-PC session locking
- [SessionHistoryManager](#sessionhistorymanager) - Historical session queries
- [SKUMappingManager](#skumappingmanager) - Barcode-to-SKU mapping

### UI Components
- [MainWindow](#mainwindow) - Main application window
- [PackerModeWidget](#packermodewidget) - Barcode scanning interface
- [DashboardWidget](#dashboardwidget) - Performance dashboard
- [SessionHistoryWidget](#sessionhistorywidget) - Session history browser
- [SessionMonitorWidget](#sessionmonitorwidget) - Active sessions monitor

### UI Dialogs
- [ColumnMappingDialog](#columnmappingdialog) - Excel column mapping
- [RestoreSessionDialog](#restoresessiondialog) - Session restoration
- [SKUMappingDialog](#skumappingdialog) - SKU mapping editor
- [PrintDialog](#printdialog) - Barcode printing

### Data Models
- [OrderTableModel](#ordertablemodel) - Qt table model for orders
- [CustomFilterProxyModel](#customfilterproxymodel) - Advanced table filtering

### Utilities
- [AppLogger](#applogger) - Centralized logging
- [Exceptions](#exceptions) - Custom exception classes

---

## Core Business Logic

### PackerLogic

**Module**: `packer_logic.py`

**Description**: Handles the core business logic of the Packer's Assistant application. Manages loading packing lists, generating barcodes, tracking packing state, and handling order completion.

#### Class Definition

```python
class PackerLogic(QObject):
    """
    Handles the core business logic of the Packer's Assistant application.

    This class is responsible for loading and processing packing lists from Excel files,
    generating Code-128 barcodes for orders, tracking the packing progress for each item,
    and handling the completion of orders. It maintains the state of all orders and items
    being packed in the current session.

    Attributes:
        item_packed (Signal): Emitted when an item is successfully packed.
            Args: order_number (str), sku (str), packed_count (int), required_count (int)
        order_completed (Signal): Emitted when an order is fully packed.
            Args: order_number (str)
        error_occurred (Signal): Emitted when an error occurs during packing.
            Args: error_message (str)
        session_data_loaded (Signal): Emitted when session data is loaded.
            Args: None
    """
```

#### Constructor

```python
def __init__(self, session_dir: Path, profile_manager, sku_mapping_manager, parent=None)
```

**Description**: Initialize PackerLogic with session directory and managers.

**Args:**
- `session_dir` (Path): Directory path for the current packing session
- `profile_manager` (ProfileManager): Manager for client profiles and storage
- `sku_mapping_manager` (SKUMappingManager): Manager for barcode-to-SKU mappings
- `parent` (QObject, optional): Parent QObject for Qt ownership

**Attributes:**
- `session_dir` (Path): Current session directory path
- `barcode_dir` (Path): Directory for generated barcode images
- `packing_state_file` (Path): JSON file storing current packing state
- `client_id` (str): Current client identifier
- `processed_df` (pd.DataFrame): Processed packing list data
- `orders_data` (Dict): Mapping of order numbers to order details
- `current_order` (str): Currently active order number
- `sku_mapping` (Dict): Barcode-to-SKU mapping dictionary

#### Public Methods

##### load_packing_list_from_file

```python
def load_packing_list_from_file(self, file_path: str, restore_dir: str = None) -> bool
```

**Description**: Load and validate packing list from Excel file.

**Args:**
- `file_path` (str): Path to Excel file containing the packing list
- `restore_dir` (str, optional): Directory to restore from for crash recovery

**Returns:**
- `bool`: True if loaded successfully, False otherwise

**Raises:**
- `FileNotFoundError`: If Excel file doesn't exist
- `ValidationError`: If required columns are missing

**Example:**
```python
success = packer_logic.load_packing_list_from_file("orders.xlsx")
if success:
    print("Packing list loaded successfully")
```

##### load_packing_list_json

**[NEW in v1.2.0 - Phase 1]**

```python
def load_packing_list_json(self, packing_list_path: Path) -> Tuple[int, str]
```

**Description**: Load packing list from Shopify session JSON file.

This method loads a specific packing list JSON file generated by Shopify Tool. Packing list JSONs are pre-filtered collections of orders ready for packing, typically organized by courier or delivery method.

**Args:**
- `packing_list_path` (Path): Full path to packing list JSON file
  - Example: `Path("\\server\\...\\packing_lists\\DHL_Orders.json")`

**Returns:**
- `Tuple[int, str]`: (total_orders, list_name)
  - `total_orders`: Number of orders in the packing list
  - `list_name`: Name of the packing list (e.g., "DHL_Orders")

**Raises:**
- `FileNotFoundError`: If packing list JSON doesn't exist
- `json.JSONDecodeError`: If JSON is malformed
- `ValidationError`: If required fields are missing

**Expected JSON Format:**
```json
{
  "list_name": "DHL_Orders",
  "created_at": "2025-11-19T10:00:00",
  "courier": "DHL",
  "total_orders": 25,
  "orders": [
    {
      "order_number": "ORDER-12345",
      "customer_name": "John Doe",
      "courier": "DHL",
      "items": [
        {
          "sku": "PROD-001",
          "title": "Product Name",
          "quantity": 2,
          "barcode": "1234567890123"
        }
      ]
    }
  ]
}
```

**Behavior:**
1. Validates file exists and is readable
2. Parses JSON and validates structure
3. Converts orders to internal DataFrame format
4. Initializes packing state for all orders
5. Returns summary information

**Example:**
```python
from pathlib import Path

# Load Shopify packing list
packing_list_path = Path("\\\\server\\...\\packing_lists\\DHL_Orders.json")
order_count, list_name = packer_logic.load_packing_list_json(packing_list_path)

print(f"Loaded '{list_name}': {order_count} orders ready for packing")
# Output: Loaded 'DHL_Orders': 25 orders ready for packing
```

**Phase 1 Integration:**
- Used exclusively for Shopify workflow
- Complements `load_packing_list_from_file()` (Excel workflow)
- Supports multiple packing lists per Shopify session
- JSON format matches Shopify Tool output specification

##### process_data_and_generate_barcodes

**Status:** ❌ REMOVED in v1.3.0.0

**Migration:** Barcode generation is now handled by Shopify Tool (Feature #5). All sessions must be created in Shopify Tool first, which generates barcodes automatically.

**Previous Functionality (v1.2.0 and earlier):**
- Processed loaded DataFrame and generated barcode images
- Created Code-128 barcodes for each order
- Saved images to barcode directory

**Replacement Workflow:**
1. Create session in Shopify Tool
2. Use Shopify Tool's Barcode Generator (Feature #5)
3. Load session in Packer Tool using `load_from_shopify_analysis()`

##### start_order_packing

```python
def start_order_packing(self, barcode_data: str) -> tuple[bool, str, list[dict]]
```

**Description**: Start packing an order by scanning its barcode.

**Args:**
- `barcode_data` (str): Scanned barcode data (order number)

**Returns:**
- `tuple[bool, str, list[dict]]`:
  - `bool`: True if order found and started
  - `str`: Status message
  - `list[dict]`: List of items in the order

**Order Status:**
- New: Not yet started, all items pending
- In Progress: Some items packed, not all complete
- Completed: All items fully packed

**Example:**
```python
success, message, items = packer_logic.start_order_packing("ORDER-123")
if success:
    print(f"Started packing order with {len(items)} items")
else:
    print(f"Error: {message}")
```

##### process_sku_scan

```python
def process_sku_scan(self, barcode_data: str) -> tuple[bool, str, int, int, bool]
```

**Description**: Process a scanned SKU barcode and update packing state.

**Args:**
- `barcode_data` (str): Scanned barcode data (SKU)

**Returns:**
- `tuple[bool, str, int, int, bool]`:
  - `bool`: Success status
  - `str`: Status message
  - `int`: Updated packed count for this SKU
  - `int`: Required count for this SKU
  - `bool`: Whether the entire order is now complete

**Processing Logic:**
1. Normalize scanned barcode (lowercase, remove spaces)
2. Apply SKU mapping if configured
3. Find matching SKU in current order
4. Increment packed count
5. Check if all items in order are complete
6. Save state to disk
7. Mark order as completed if all items packed

**Example:**
```python
success, msg, packed, required, order_complete = packer_logic.process_sku_scan("SKU-001")
if success:
    print(f"Packed {packed}/{required} of this item")
    if order_complete:
        print("Order complete!")
```

##### get_order_details

```python
def get_order_details(self, order_number: str) -> list[dict]
```

**Description**: Retrieve detailed information about a specific order.

**Args:**
- `order_number` (str): The order number to retrieve

**Returns:**
- `list[dict]`: List of items in the order with details:
  ```python
  [
      {
          'SKU': 'SKU-001',
          'Product_Name': 'Widget A',
          'Quantity': 5,
          'Order_Number': 'ORDER-123',
          'Courier': 'DHL'
      },
      ...
  ]
  ```

##### get_order_state

```python
def get_order_state(self, order_number: str) -> list[dict]
```

**Description**: Get the current packing state for an order.

**Args:**
- `order_number` (str): The order number

**Returns:**
- `list[dict]`: Packing state for each SKU:
  ```python
  [
      {
          'row': 0,
          'sku': 'SKU-001',
          'normalized_sku': 'sku001',
          'required': 5,
          'packed': 3
      },
      ...
  ]
  ```

##### is_order_complete

```python
def is_order_complete(self, order_number: str) -> bool
```

**Description**: Check if an order is fully packed.

**Args:**
- `order_number` (str): The order number to check

**Returns:**
- `bool`: True if all items in order are fully packed

##### get_summary_data

```python
def get_summary_data(self) -> pd.DataFrame
```

**Description**: Get summary statistics for all orders.

**Returns:**
- `pd.DataFrame`: Summary with columns:
  - Order_Number: Order identifier
  - Total_Items: Number of unique SKUs
  - Status: "New", "In Progress", or "Completed"
  - Progress: Formatted as "X/Y items"

**Example:**
```python
summary = packer_logic.get_summary_data()
print(summary[['Order_Number', 'Status', 'Progress']])
```

##### save_state

```python
def save_state(self)
```

**Description**: Save current packing state to JSON file.

**File Location**: `session_dir/barcodes/packing_state.json`

**State Structure:**
```json
{
  "version": "1.0",
  "timestamp": "2025-11-03T14:35:00",
  "client_id": "M",
  "data": {
    "in_progress": {
      "ORDER-123": {
        "SKU-001": {
          "required": 5,
          "packed": 3,
          "normalized_sku": "sku001"
        }
      }
    },
    "completed_orders": ["ORDER-456"]
  }
}
```

##### load_state

```python
def load_state(self)
```

**Description**: Load packing state from JSON file for crash recovery.

**Raises:**
- `FileNotFoundError`: If state file doesn't exist
- `json.JSONDecodeError`: If state file is corrupted

##### end_session_cleanup

```python
def end_session_cleanup(self)
```

**Description**: Clean up session files when session ends normally.

**Actions:**
- Delete `packing_state.json` (no longer needed after completion)
- Keep barcode images for reference
- Keep completed packing list in output/ directory

#### Private Methods

##### _validate_and_map_columns

```python
def _validate_and_map_columns(self, file_path: str, required_columns: list[str]) -> tuple[bool, dict]
```

**Description**: Validate that required columns exist, prompt for mapping if needed.

**Args:**
- `file_path` (str): Path to Excel file
- `required_columns` (list[str]): List of required column names

**Returns:**
- `tuple[bool, dict]`:
  - `bool`: True if validation successful
  - `dict`: Mapping from required columns to file columns

##### _generate_code128_barcode

```python
def _generate_code128_barcode(self, barcode_data: str, file_path: Path, label_text: str, courier: str = None)
```

**Description**: Generate a Code-128 barcode image with order and courier information.

**Args:**
- `barcode_data` (str): Data to encode (order number)
- `file_path` (Path): Output file path for PNG
- `label_text` (str): Text to display below barcode
- `courier` (str, optional): Courier name to display

**Barcode Specifications:**
- Format: Code-128
- DPI: 203 (thermal printer standard)
- Size: 65mm x 35mm
- Font: Arial Bold, 14pt for order, 12pt for courier

##### _normalize_sku

```python
def _normalize_sku(self, sku: str) -> str
```

**Description**: Normalize SKU for comparison (lowercase, strip spaces).

**Args:**
- `sku` (str): Original SKU string

**Returns:**
- `str`: Normalized SKU

**Example:**
```python
normalized = self._normalize_sku("SKU-001  ")  # Returns "sku-001"
```

##### _normalize_order_number

```python
def _normalize_order_number(self, order_number: str) -> str
```

**Description**: Normalizes order numbers for barcode matching. Removes special characters (#, !, spaces) while keeping alphanumeric, hyphens, and underscores. This matches the normalization logic used by Shopify Tool's barcode generation.

**Added in:** v1.3.0.0

**Args:**
- `order_number` (str): Raw order number (may contain #, !, spaces, etc.)

**Returns:**
- `str`: Normalized order number (alphanumeric + hyphens + underscores only)

**Example:**
```python
result = logic._normalize_order_number("#ORDER-123!")
# Returns: "ORDER-123"

result = logic._normalize_order_number("ORDER 456")
# Returns: "ORDER456"
```

**Used by:** `start_order_packing()` for barcode scanning workflow

##### _apply_sku_mapping

```python
def _apply_sku_mapping(self, scanned_barcode: str) -> str
```

**Description**: Apply SKU mapping translation if configured.

**Args:**
- `scanned_barcode` (str): Barcode scanned from product

**Returns:**
- `str`: Mapped internal SKU, or original if no mapping exists

---

### SessionManager

**Module**: `session_manager.py`

**Description**: Manages the lifecycle of packing sessions including creation, organization by client, state tracking, and cleanup. Integrates with ProfileManager for centralized storage.

#### Class Definition

```python
class SessionManager(QObject):
    """
    Manages the lifecycle of packing sessions.

    This class handles session creation, organization by client, and session
    state tracking. It integrates with ProfileManager for centralized storage
    on the file server.

    Signals:
        session_started (str): Emitted when a session starts (session_id)
        session_ended (str): Emitted when a session ends (session_id)
        heartbeat_failed (): Emitted when heartbeat update fails
    """
```

#### Constructor

```python
def __init__(self, profile_manager, lock_manager, parent=None)
```

**Description**: Initialize SessionManager with required managers.

**Args:**
- `profile_manager` (ProfileManager): Profile manager for file operations
- `lock_manager` (SessionLockManager): Lock manager for session coordination
- `parent` (QObject, optional): Parent QObject

**Attributes:**
- `profile_manager` (ProfileManager): Reference to profile manager
- `lock_manager` (SessionLockManager): Reference to lock manager
- `current_session_dir` (Path): Current active session directory
- `current_client_id` (str): Current client identifier
- `heartbeat_timer` (QTimer): Timer for periodic heartbeat updates

#### Public Methods

##### start_session

```python
def start_session(self, packing_list_path: str, restore_dir: str = None) -> str
```

**Description**: Start a new packing session or restore an existing one.

**Args:**
- `packing_list_path` (str): Path to Excel file with packing list
- `restore_dir` (str, optional): Directory path to restore from

**Returns:**
- `str`: Session ID (timestamp-based directory name)

**Raises:**
- `SessionLockedError`: If session is locked by another PC
- `IOError`: If unable to create session directory

**Session Creation Steps:**
1. Generate timestamped session ID (format: YYYYMMDD_HHMMSS)
2. Create session directory structure
3. Acquire session lock
4. Save session_info.json with metadata
5. Start heartbeat timer (60-second intervals)
6. Emit session_started signal

**Example:**
```python
session_id = session_manager.start_session("orders.xlsx")
print(f"Session started: {session_id}")
```

##### end_session

```python
def end_session(self)
```

**Description**: End the current session gracefully.

**Actions:**
1. Stop heartbeat timer
2. Release session lock
3. Delete session_info.json (marks session as complete)
4. Emit session_ended signal
5. Clear current session state

##### get_session_info

```python
def get_session_info(self) -> dict
```

**Description**: Get information about the current session.

**Returns:**
- `dict`: Session information:
  ```python
  {
      'session_id': '2025-11-03_14-30',
      'client_id': 'M',
      'packing_list_path': 'C:\\Users\\...\\orders.xlsx',
      'started_at': '2025-11-03T14:30:00',
      'pc_name': 'PC-WAREHOUSE-1',
      'session_dir': Path(...)
  }
  ```

##### is_session_active

```python
def is_session_active(self) -> bool
```

**Description**: Check if a session is currently active.

**Returns:**
- `bool`: True if session is active

##### get_packing_work_dir

**[NEW in v1.2.0 - Phase 1]**

```python
def get_packing_work_dir(self, session_path: str, packing_list_name: str) -> Path
```

**Description**: Get or create working directory for packing results within a Shopify session.

Creates a Phase 1 directory structure for organizing packing data within a Shopify session. This method supports multiple packing lists per session by creating isolated working directories.

**Args:**
- `session_path` (str): Full path to Shopify session directory
  - Example: `\\server\...\Sessions\CLIENT_M\2025-11-19_1`
- `packing_list_name` (str): Name of the packing list (without .json extension)
  - Example: `"DHL_Orders"`

**Returns:**
- `Path`: Working directory path
  - Example: `Path("...\\2025-11-19_1\\packing\\DHL_Orders")`

**Directory Structure Created:**
```
{session_path}/packing/{packing_list_name}/
├── barcodes/          # Barcode PNG files and packing state
└── reports/           # Completion reports and summaries
```

**Behavior:**
1. Constructs path: `{session_path}/packing/{packing_list_name}`
2. Creates directory if it doesn't exist
3. Creates subdirectories: `barcodes/` and `reports/`
4. Returns Path object for use by PackerLogic

**Example:**
```python
# For Shopify session with multiple packing lists
work_dir = session_manager.get_packing_work_dir(
    session_path="\\\\server\\...\\Sessions\\CLIENT_M\\2025-11-19_1",
    packing_list_name="DHL_Orders"
)
# Returns: Path("...\\2025-11-19_1\\packing\\DHL_Orders")

# Each packing list gets its own isolated directory
work_dir_2 = session_manager.get_packing_work_dir(
    session_path="\\\\server\\...\\Sessions\\CLIENT_M\\2025-11-19_1",
    packing_list_name="PostOne_Orders"
)
# Returns: Path("...\\2025-11-19_1\\packing\\PostOne_Orders")
```

**Phase 1 Integration:**
- Used by Shopify workflow to support multiple packing lists per session
- Maintains backward compatibility with Excel workflow (single session directory)
- Each packing list maintains isolated state and results

#### Private Methods

##### _create_session_directory

```python
def _create_session_directory(self, client_id: str) -> tuple[Path, str]
```

**Description**: Create timestamped session directory.

**Args:**
- `client_id` (str): Client identifier

**Returns:**
- `tuple[Path, str]`: Session directory path and session ID

##### _save_session_info

```python
def _save_session_info(self, packing_list_path: str)
```

**Description**: Save session metadata to session_info.json.

**Args:**
- `packing_list_path` (str): Path to source packing list

##### _update_heartbeat

```python
def _update_heartbeat(self)
```

**Description**: Update session lock heartbeat (called by timer every 60s).

**Emits**: `heartbeat_failed` signal if update fails

---

### ProfileManager

**Module**: `profile_manager.py`

**Description**: Manages client profiles and configuration on the centralized file server. Handles profile CRUD operations, SKU mappings, and session directory organization.

#### Class Definition

```python
class ProfileManager:
    """
    Manages client profiles and configuration on the centralized file server.

    This class is responsible for:
    - Creating and managing client profiles
    - Handling SKU mapping storage with file locking
    - Organizing session directories
    - Caching frequently accessed configurations
    - Testing network connectivity

    Attributes:
        file_server_root (Path): Root directory on file server
        clients_root (Path): Directory containing client profiles
        sessions_root (Path): Directory containing session data
        stats_root (Path): Directory containing statistics
    """
```

#### Constructor

```python
def __init__(self, file_server_root: str)
```

**Description**: Initialize ProfileManager with file server root path.

**Args:**
- `file_server_root` (str): Root path on file server (e.g., "\\\\Server\\Share")

**Raises:**
- `NetworkError`: If file server is not accessible

**Initialization:**
1. Convert path to Path object
2. Test connectivity to file server
3. Create directory structure if needed:
   - CLIENTS/
   - SESSIONS/
   - STATS/
4. Initialize configuration cache

##### create_client_profile

```python
def create_client_profile(self, client_id: str, config: dict = None) -> bool
```

**Description**: Create a new client profile.

**Args:**
- `client_id` (str): Unique client identifier (single character recommended)
- `config` (dict, optional): Initial configuration dictionary

**Returns:**
- `bool`: True if created successfully

**Directory Structure:**
```
CLIENTS/CLIENT_{client_id}/
├── config.json
├── sku_mapping.json
└── backups/
```

**Example:**
```python
success = profile_manager.create_client_profile(
    "M",
    config={"name": "Client M", "warehouse": "Main"}
)
```

##### get_client_config

```python
def get_client_config(self, client_id: str) -> dict
```

**Description**: Load client configuration with caching.

**Args:**
- `client_id` (str): Client identifier

**Returns:**
- `dict`: Client configuration or empty dict if not found

**Caching**: Configuration cached for 60 seconds to reduce file I/O

##### update_client_config

```python
def update_client_config(self, client_id: str, config: dict) -> bool
```

**Description**: Update client configuration with backup.

**Args:**
- `client_id` (str): Client identifier
- `config` (dict): New configuration

**Returns:**
- `bool`: True if updated successfully

**Backup Policy**: Last 10 configurations kept in backups/ directory

##### load_sku_mapping

```python
def load_sku_mapping(self, client_id: str) -> dict
```

**Description**: Load SKU mapping for a client with file locking.

**Args:**
- `client_id` (str): Client identifier

**Returns:**
- `dict`: Barcode-to-SKU mapping dictionary

**File Locking**: Uses msvcrt.locking() for safe concurrent access

**Example:**
```python
mapping = profile_manager.load_sku_mapping("M")
# Returns: {"product_barcode_001": "SKU-001", ...}
```

##### save_sku_mapping

```python
def save_sku_mapping(self, client_id: str, mapping: dict) -> bool
```

**Description**: Save SKU mapping with file locking and backup.

**Args:**
- `client_id` (str): Client identifier
- `mapping` (dict): Barcode-to-SKU mapping

**Returns:**
- `bool`: True if saved successfully

**Safety Features:**
- Atomic write (temp file + move)
- File locking during write
- Automatic backup of previous version
- Retry logic (3 attempts with exponential backoff)

##### list_clients

```python
def list_clients(self) -> list[str]
```

**Description**: List all available clients.

**Returns:**
- `list[str]`: List of client IDs

**Example:**
```python
clients = profile_manager.list_clients()
# Returns: ['M', 'R', 'A']
```

##### get_incomplete_sessions

```python
def get_incomplete_sessions(self, client_id: str) -> list[Path]
```

**Description**: Find sessions that were not completed (have session_info.json).

**Args:**
- `client_id` (str): Client identifier

**Returns:**
- `list[Path]`: List of incomplete session directory paths

**Detection**: Sessions with session_info.json present are considered incomplete

##### get_clients_root

```python
def get_clients_root(self) -> Path
```

**Description**: Get path to clients root directory.

**Returns:**
- `Path`: Path to CLIENTS/ directory

##### get_sessions_root

```python
def get_sessions_root(self) -> Path
```

**Description**: Get path to sessions root directory.

**Returns:**
- `Path`: Path to SESSIONS/ directory

##### get_stats_root

```python
def get_stats_root(self) -> Path
```

**Description**: Get path to statistics root directory.

**Returns:**
- `Path`: Path to STATS/ directory

##### test_connectivity

```python
def test_connectivity(self) -> bool
```

**Description**: Test if file server is accessible.

**Returns:**
- `bool`: True if accessible

**Test Method**: Attempts to list directory contents

---

### StatisticsManager

**Module**: `statistics_manager.py`

**Description**: Centralized statistics tracking and analytics. Maintains global statistics across all clients and sessions, tracks unique orders, and generates performance metrics.

#### Class Definition

```python
class StatisticsManager:
    """
    Manages centralized statistics and analytics.

    This class tracks:
    - Unique orders processed globally
    - Completed orders count
    - Per-client statistics (sessions, orders, items, duration)
    - Session history for reporting
    - Performance metrics (orders/hour, items/hour)

    All statistics are stored in a centralized JSON file with file locking
    for multi-PC safety.
    """
```

#### Constructor

```python
def __init__(self, profile_manager)
```

**Description**: Initialize StatisticsManager with profile manager.

**Args:**
- `profile_manager` (ProfileManager): Profile manager for accessing stats directory

**Attributes:**
- `stats_file` (Path): Path to centralized stats.json
- `stats_data` (dict): In-memory statistics cache
- `logger` (Logger): Logger instance

#### Public Methods

##### record_session_completion

```python
def record_session_completion(
    self,
    client_id: str,
    session_id: str,
    completed_orders: int,
    total_items: int,
    duration_seconds: float,
    session_metadata: dict = None
) -> bool
```

**Description**: Record a completed session's statistics.

**Args:**
- `client_id` (str): Client identifier
- `session_id` (str): Session identifier
- `completed_orders` (int): Number of orders completed
- `total_items` (int): Total items packed
- `duration_seconds` (float): Session duration in seconds
- `session_metadata` (dict, optional): Additional session information

**Returns:**
- `bool`: True if recorded successfully

**Updates:**
- Increments client's total_sessions count
- Adds to client's total_orders and total_items
- Accumulates total_duration_seconds
- Appends to session_history array

**Example:**
```python
success = stats_manager.record_session_completion(
    client_id="M",
    session_id="2025-11-03_14-30",
    completed_orders=150,
    total_items=567,
    duration_seconds=4500
)
```

##### get_client_stats

```python
def get_client_stats(self, client_id: str) -> dict
```

**Description**: Get statistics for a specific client.

**Args:**
- `client_id` (str): Client identifier

**Returns:**
- `dict`: Client statistics:
  ```python
  {
      'total_sessions': 45,
      'total_orders': 1234,
      'total_items': 5678,
      'total_duration_seconds': 36000,
      'average_orders_per_session': 27.4,
      'average_duration_minutes': 13.3
  }
  ```

##### get_global_stats

```python
def get_global_stats(self) -> dict
```

**Description**: Get global statistics across all clients.

**Returns:**
- `dict`: Global statistics:
  ```python
  {
      'total_unique_orders': 5432,
      'total_completed_orders': 5400,
      'total_clients': 3,
      'total_sessions': 150,
      'total_items': 20000
  }
  ```

##### get_performance_metrics

```python
def get_performance_metrics(self, client_id: str = None, days: int = 30) -> dict
```

**Description**: Calculate performance metrics for a time period.

**Args:**
- `client_id` (str, optional): Specific client or None for all clients
- `days` (int): Number of days to analyze (default: 30)

**Returns:**
- `dict`: Performance metrics:
  ```python
  {
      'total_sessions': 50,
      'total_orders': 1500,
      'total_items': 6000,
      'total_duration_hours': 100,
      'average_orders_per_session': 30.0,
      'average_items_per_session': 120.0,
      'average_duration_minutes': 120.0,
      'orders_per_hour': 15.0,
      'items_per_hour': 60.0
  }
  ```

**Calculations:**
- `orders_per_hour` = total_orders / total_duration_hours
- `items_per_hour` = total_items / total_duration_hours
- `average_duration_minutes` = (total_duration_seconds / sessions) / 60

##### track_unique_order

```python
def track_unique_order(self, order_id: str) -> bool
```

**Description**: Track a unique order ID globally.

**Args:**
- `order_id` (str): Order identifier to track

**Returns:**
- `bool`: True if this is a new unique order, False if already tracked

**Purpose**: Prevent double-counting orders across multiple sessions

##### is_order_tracked

```python
def is_order_tracked(self, order_id: str) -> bool
```

**Description**: Check if an order has been processed before.

**Args:**
- `order_id` (str): Order identifier

**Returns:**
- `bool`: True if order has been processed

##### get_session_history

```python
def get_session_history(self, client_id: str = None, limit: int = 100) -> list[dict]
```

**Description**: Retrieve session history with optional filtering.

**Args:**
- `client_id` (str, optional): Filter by client
- `limit` (int): Maximum sessions to return

**Returns:**
- `list[dict]`: List of session records sorted by timestamp (newest first)

**Example:**
```python
history = stats_manager.get_session_history(client_id="M", limit=50)
for session in history:
    print(f"{session['session_id']}: {session['completed_orders']} orders")
```

#### Private Methods

##### _load_stats

```python
def _load_stats(self) -> dict
```

**Description**: Load statistics from JSON file with file locking.

**Returns:**
- `dict`: Statistics data or default structure if file doesn't exist

##### _save_stats

```python
def _save_stats(self) -> bool
```

**Description**: Save statistics to JSON file with atomic write.

**Returns:**
- `bool`: True if saved successfully

---

## Data Management

### SessionLockManager

**Module**: `session_lock_manager.py`

**Description**: Provides file-based locking mechanism for multi-PC coordination. Ensures only one user can work on a session at a time with crash recovery support via heartbeat mechanism.

#### Class Definition

```python
class SessionLockManager:
    """
    Manages session locks to prevent concurrent access.

    Features:
    - File-based locking with .session.lock files
    - Heartbeat mechanism to detect crashed sessions
    - Stale lock detection and recovery
    - Detailed lock information for UI display

    Constants:
        LOCK_FILENAME (str): ".session.lock"
        HEARTBEAT_INTERVAL (int): 60 seconds
        STALE_TIMEOUT (int): 120 seconds
    """
```

#### Constructor

```python
def __init__(self, profile_manager)
```

**Description**: Initialize SessionLockManager.

**Args:**
- `profile_manager` (ProfileManager): Profile manager for accessing session directories

**Attributes:**
- `profile_manager` (ProfileManager): Reference to profile manager
- `logger` (Logger): Logger instance
- `hostname` (str): Current computer hostname
- `username` (str): Current Windows username
- `process_id` (int): Current process ID
- `app_version` (str): Application version

#### Public Methods

##### acquire_lock

```python
def acquire_lock(self, client_id: str, session_dir: Path) -> tuple[bool, Optional[str]]
```

**Description**: Attempt to acquire a lock on the session.

**Args:**
- `client_id` (str): Client identifier
- `session_dir` (Path): Path to session directory

**Returns:**
- `tuple[bool, Optional[str]]`:
  - `bool`: True if lock acquired successfully
  - `str`: Error message if failed, None if successful

**Lock Acquisition Logic:**
1. Check if lock file exists
2. If exists and belongs to current process: Update heartbeat
3. If exists and belongs to another process:
   - Check if lock is stale (> 2 min without heartbeat)
   - If stale: Return error with force-release option
   - If active: Return error (session in use)
4. If no lock: Create new lock file

**Example:**
```python
success, error_msg = lock_manager.acquire_lock("M", session_dir)
if not success:
    print(f"Cannot acquire lock: {error_msg}")
```

##### release_lock

```python
def release_lock(self, session_dir: Path) -> bool
```

**Description**: Release the lock on a session.

**Args:**
- `session_dir` (Path): Path to session directory

**Returns:**
- `bool`: True if lock was released

**Safety**: Only releases lock if it belongs to current process

##### is_locked

```python
def is_locked(self, session_dir: Path) -> tuple[bool, Optional[dict]]
```

**Description**: Check if a session is locked.

**Args:**
- `session_dir` (Path): Path to session directory

**Returns:**
- `tuple[bool, Optional[dict]]`:
  - `bool`: True if locked
  - `dict`: Lock information or None

**Lock Information:**
```python
{
    'locked_by': 'PC-WAREHOUSE-1',
    'user_name': 'john.smith',
    'lock_time': '2025-11-03T14:30:00',
    'process_id': 12345,
    'app_version': '1.2.0',
    'heartbeat': '2025-11-03T14:32:00'
}
```

##### update_heartbeat

```python
def update_heartbeat(self, session_dir: Path) -> bool
```

**Description**: Update the heartbeat timestamp in the lock file.

**Args:**
- `session_dir` (Path): Path to session directory

**Returns:**
- `bool`: True if heartbeat updated successfully

**Called By**: SessionManager's heartbeat timer every 60 seconds

**Safety Features:**
- File locking during update (msvcrt.locking)
- Retry logic (3 attempts with 0.1s delay)
- Verification that lock belongs to current process

##### is_lock_stale

```python
def is_lock_stale(self, lock_info: dict, stale_timeout: Optional[int] = None) -> bool
```

**Description**: Check if a lock is stale (no recent heartbeat).

**Args:**
- `lock_info` (dict): Lock information dictionary
- `stale_timeout` (int, optional): Timeout in seconds (default: 120)

**Returns:**
- `bool`: True if lock is stale

**Stale Criteria**: Heartbeat timestamp more than 2 minutes old

##### force_release_lock

```python
def force_release_lock(self, session_dir: Path) -> bool
```

**Description**: Forcefully release a lock, regardless of who owns it.

**Args:**
- `session_dir` (Path): Path to session directory

**Returns:**
- `bool`: True if lock was released

**Use Case**: Stale locks from crashed sessions

**Warning**: Should only be used after confirming lock is stale

##### get_lock_display_info

```python
def get_lock_display_info(self, lock_info: dict) -> str
```

**Description**: Format lock information for display to user.

**Args:**
- `lock_info` (dict): Lock information dictionary

**Returns:**
- `str`: Formatted string for UI display:
  ```
  Locked by: john.smith
  Computer: PC-WAREHOUSE-1
  Since: 03.11.2025 14:30
  ```

##### get_all_active_sessions

```python
def get_all_active_sessions(self) -> dict[str, list]
```

**Description**: Get all active sessions across all clients.

**Returns:**
- `dict[str, list]`: Dictionary mapping client_id to list of active sessions:
  ```python
  {
      'M': [
          {
              'session_name': '2025-11-03_14-30',
              'session_dir': Path(...),
              'lock_info': {...}
          }
      ],
      'R': [...]
  }
  ```

**Purpose**: For monitoring dashboard to show all active sessions

---

### SessionHistoryManager

**Module**: `session_history_manager.py`

**Description**: Manages historical session data retrieval and analytics. Provides functionality to query, search, and analyze completed packing sessions.

#### Class Definition

```python
class SessionHistoryManager:
    """
    Manages historical session data retrieval and analytics.

    This class provides methods to scan session directories, extract metrics
    from completed sessions, and generate analytics reports for clients.
    """
```

#### Constructor

```python
def __init__(self, profile_manager)
```

**Description**: Initialize SessionHistoryManager.

**Args:**
- `profile_manager` (ProfileManager): Profile manager for accessing session paths

#### Public Methods

##### get_client_sessions

```python
def get_client_sessions(
    self,
    client_id: str,
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
    include_incomplete: bool = True
) -> list[SessionHistoryRecord]
```

**Description**: Retrieve all sessions for a specific client.

**Args:**
- `client_id` (str): Client identifier
- `start_date` (datetime, optional): Filter sessions after this date
- `end_date` (datetime, optional): Filter sessions before this date
- `include_incomplete` (bool): Include sessions still in progress

**Returns:**
- `list[SessionHistoryRecord]`: List of session records, sorted by start time (newest first)

**SessionHistoryRecord Fields:**
- `session_id` (str): Session identifier
- `client_id` (str): Client identifier
- `start_time` (datetime): Session start timestamp
- `end_time` (datetime): Session end timestamp
- `duration_seconds` (float): Total duration
- `total_orders` (int): Total orders in session
- `completed_orders` (int): Completed orders
- `in_progress_orders` (int): Incomplete orders
- `total_items_packed` (int): Total items packed
- `pc_name` (str): Computer name
- `packing_list_path` (str): Original file path
- `session_path` (str): Session directory path

**Example:**
```python
# Get last 30 days of sessions
start = datetime.now() - timedelta(days=30)
sessions = history_manager.get_client_sessions(
    "M",
    start_date=start,
    include_incomplete=False
)
print(f"Found {len(sessions)} completed sessions")
```

##### get_client_analytics

```python
def get_client_analytics(
    self,
    client_id: str,
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None
) -> ClientAnalytics
```

**Description**: Generate analytics for a specific client.

**Args:**
- `client_id` (str): Client identifier
- `start_date` (datetime, optional): Include sessions after this date
- `end_date` (datetime, optional): Include sessions before this date

**Returns:**
- `ClientAnalytics`: Aggregated metrics object

**ClientAnalytics Fields:**
- `client_id` (str): Client identifier
- `total_sessions` (int): Total number of sessions
- `total_orders_packed` (int): Total orders across all sessions
- `average_orders_per_session` (float): Average orders per session
- `average_session_duration_minutes` (float): Average duration in minutes
- `total_items_packed` (int): Total items packed
- `last_session_date` (datetime): Most recent session date

##### search_sessions

```python
def search_sessions(
    self,
    client_id: str,
    search_term: str,
    search_fields: list[str] = None
) -> list[SessionHistoryRecord]
```

**Description**: Search sessions by various fields.

**Args:**
- `client_id` (str): Client identifier
- `search_term` (str): Search term to match
- `search_fields` (list[str], optional): Fields to search (default: all text fields)

**Returns:**
- `list[SessionHistoryRecord]`: List of matching sessions

**Searchable Fields:**
- session_id
- pc_name
- packing_list_path

**Example:**
```python
# Search for sessions from specific PC
results = history_manager.search_sessions("M", "PC-WAREHOUSE-1")

# Search for sessions with specific file
results = history_manager.search_sessions("M", "orders_2025")
```

##### get_session_details

```python
def get_session_details(self, client_id: str, session_id: str) -> Optional[dict]
```

**Description**: Get detailed information about a specific session.

**Args:**
- `client_id` (str): Client identifier
- `session_id` (str): Session identifier

**Returns:**
- `dict`: Detailed session information:
  ```python
  {
      'record': SessionHistoryRecord object,
      'packing_state': {dict from packing_state.json},
      'session_info': {dict from session_info.json}
  }
  ```

##### export_sessions_to_dict

```python
def export_sessions_to_dict(self, sessions: list[SessionHistoryRecord]) -> list[dict]
```

**Description**: Export sessions to list of dictionaries suitable for DataFrame.

**Args:**
- `sessions` (list[SessionHistoryRecord]): Sessions to export

**Returns:**
- `list[dict]`: List of session data dictionaries for pandas/Excel export

**Output Format:**
```python
[
    {
        'Session ID': '2025-11-03_14-30',
        'Client ID': 'M',
        'Start Time': '2025-11-03 14:30:00',
        'End Time': '2025-11-03 15:45:00',
        'Duration (minutes)': 75.0,
        'Total Orders': 150,
        'Completed Orders': 148,
        'In Progress': 2,
        'Items Packed': 567,
        'PC Name': 'PC-WAREHOUSE-1',
        'Packing List': 'C:\\Users\\...\\orders.xlsx'
    },
    ...
]
```

---

### SKUMappingManager

**Module**: `sku_mapping_manager.py`

**Description**: Manages the persistence of Barcode-to-SKU mapping. Handles loading, saving, and accessing mapping data stored in user's home directory.

**Note**: This class is being phased out in favor of centralized storage via ProfileManager. Kept for backward compatibility.

#### Class Definition

```python
class SKUMappingManager:
    """
    Manages the persistence of the Barcode-to-SKU mapping.

    This class handles loading the mapping from a JSON file, saving it back,
    and providing access to the data. It ensures that the mapping persists
    across application sessions.

    Note: Phase 1.3+ uses ProfileManager for centralized storage.
    This class is kept for local fallback and backward compatibility.
    """
```

#### Constructor

```python
def __init__(self)
```

**Description**: Initialize the manager and load existing mappings.

**Attributes:**
- `config_dir` (str): Configuration directory path (~/.packers_assistant)
- `map_file_path` (str): Path to sku_map.json
- `sku_map` (dict): In-memory mapping dictionary

#### Public Methods

##### load_map

```python
def load_map(self) -> dict[str, str]
```

**Description**: Load the SKU map from the JSON file.

**Returns:**
- `dict[str, str]`: Barcode-to-SKU mapping

**Fallback**: Returns empty dict if file doesn't exist or is corrupted

##### save_map

```python
def save_map(self, sku_map: dict[str, str])
```

**Description**: Save the provided SKU map to the JSON file.

**Args:**
- `sku_map` (dict[str, str]): Mapping to save

**File Format:**
```json
{
  "product_barcode_001": "SKU-001",
  "product_barcode_002": "SKU-002",
  ...
}
```

##### get_map

```python
def get_map(self) -> dict[str, str]
```

**Description**: Get the current in-memory SKU map.

**Returns:**
- `dict[str, str]`: Current SKU mapping

---

## UI Components

### MainWindow

**Module**: `main.py`

**Description**: Main application window orchestrating all components. Manages client selection, session workflow, and coordinates between different views.

#### Class Definition

```python
class MainWindow(QMainWindow):
    """
    Main application window for Packer's Assistant.

    Coordinates:
    - Client selection and profile management
    - Session creation and restoration
    - Barcode scanning workflow
    - Navigation between views (Session, Dashboard, History)
    - Audio feedback for scanning events
    """
```

#### Constructor

```python
def __init__(self, profile_manager, lock_manager, stats_manager)
```

**Description**: Initialize MainWindow with required managers.

**Args:**
- `profile_manager` (ProfileManager): Profile manager instance
- `lock_manager` (SessionLockManager): Lock manager instance
- `stats_manager` (StatisticsManager): Statistics manager instance

**Initialization:**
1. Set up UI components
2. Load available clients
3. Initialize audio files (success/error sounds)
4. Set up signal connections
5. Load stylesheet (dark theme)

#### Public Methods

##### start_session

```python
def start_session(self)
```

**Description**: Start a new packing session.

**Workflow:**
1. Prompt user to select Excel file
2. Create session via SessionManager
3. Initialize PackerLogic
4. Load and process packing list
5. Generate barcodes
6. Switch to Packer Mode view

##### end_session

```python
def end_session(self)
```

**Description**: End the current session and generate report.

**Workflow:**
1. Generate completion report Excel
2. Record statistics
3. Save session summary
4. Clean up session files
5. Release lock
6. Return to menu view

##### restore_session

```python
def restore_session(self)
```

**Description**: Restore an incomplete session after crash.

**Workflow:**
1. Show RestoreSessionDialog
2. User selects session to restore
3. Handle stale locks if needed
4. Load packing state
5. Restore UI to previous state

##### switch_to_dashboard

```python
def switch_to_dashboard(self)
```

**Description**: Switch to dashboard view.

##### switch_to_history

```python
def switch_to_history(self)
```

**Description**: Switch to session history view.

#### Private Methods

##### _on_scanner_input

```python
def _on_scanner_input(self, barcode_data: str)
```

**Description**: Handle barcode scan events.

**Args:**
- `barcode_data` (str): Scanned barcode data

**Logic:**
1. Determine if barcode is order or SKU
2. If order: Start order packing
3. If SKU: Process SKU scan
4. Update UI with result
5. Play appropriate sound (success/error/complete)
6. Show visual feedback (flash green/red border)

##### _on_item_packed

```python
def _on_item_packed(self, order_number: str, sku: str, packed_count: int, required_count: int)
```

**Description**: Handle item_packed signal from PackerLogic.

**Args:**
- `order_number` (str): Order number
- `sku` (str): SKU that was packed
- `packed_count` (int): New packed count
- `required_count` (int): Required count

**Actions:**
- Update packer mode table row
- Update main order table status
- Play success sound

##### _on_order_completed

```python
def _on_order_completed(self, order_number: str)
```

**Description**: Handle order_completed signal.

**Args:**
- `order_number` (str): Completed order number

**Actions:**
- Show victory notification
- Play completion sound
- Add to history table
- Auto-clear after 3 seconds
- Mark order as complete in main table

---

### PackerModeWidget

**Module**: `packer_mode_widget.py`

**Description**: User interface for the main "Packer Mode" screen. Displays items for current order, provides visual feedback, and captures barcode scanner input.

#### Class Definition

```python
class PackerModeWidget(QWidget):
    """
    The user interface for the main "Packer Mode" screen.

    This widget displays the items for the currently active order, provides
    visual feedback on scanning actions, and captures input from a barcode
    scanner.

    Signals:
        barcode_scanned (str): Emitted when a barcode is scanned
        exit_packing_mode (): Emitted when user clicks exit button
    """
```

#### Constructor

```python
def __init__(self, parent: QWidget = None)
```

**Description**: Initialize PackerModeWidget and UI components.

**UI Components:**
- `table` (QTableWidget): Items table for current order
- `table_frame` (QFrame): Frame around table for visual feedback
- `status_label` (QLabel): Current order status
- `notification_label` (QLabel): Large notifications (e.g., "ORDER COMPLETE")
- `scanner_input` (QLineEdit): Hidden input for barcode scanner
- `raw_scan_label` (QLabel): Display last scanned barcode
- `history_table` (QTableWidget): Recent scanned orders
- `exit_button` (QPushButton): Return to menu button

#### Public Methods

##### display_order

```python
def display_order(self, items: list[dict], order_state: list[dict])
```

**Description**: Populate the items table with order details.

**Args:**
- `items` (list[dict]): List of items in the order
- `order_state` (list[dict]): Current packing state

**Item Dictionary Format:**
```python
{
    'Product_Name': 'Widget A',
    'SKU': 'SKU-001',
    'Quantity': 5,
    'Order_Number': 'ORDER-123'
}
```

**State Dictionary Format:**
```python
{
    'row': 0,
    'packed': 3,
    'required': 5
}
```

**Table Columns:**
1. Product Name
2. SKU
3. Packed / Required (e.g., "3 / 5")
4. Status ("Pending" or "Packed")
5. Action (Confirm Manually button)

##### update_item_row

```python
def update_item_row(self, row: int, packed_count: int, is_complete: bool)
```

**Description**: Update a single table row with new packed count.

**Args:**
- `row` (int): Table row index
- `packed_count` (int): New packed count
- `is_complete` (bool): Whether this item is fully packed

**Visual Updates:**
- Update "Packed / Required" text
- Change background color (yellow → green)
- Disable "Confirm Manually" button if complete

##### show_notification

```python
def show_notification(self, text: str, color_name: str)
```

**Description**: Display a large colored notification.

**Args:**
- `text` (str): Notification message
- `color_name` (str): Color name ("green", "red", etc.)

**Example:**
```python
widget.show_notification("ORDER COMPLETE!", "green")
```

##### clear_screen

```python
def clear_screen(self)
```

**Description**: Reset widget to initial state for next order.

**Actions:**
- Clear items table
- Reset status label
- Clear notification
- Enable scanner input
- Set focus to scanner

##### set_focus_to_scanner

```python
def set_focus_to_scanner(self)
```

**Description**: Set keyboard focus to hidden scanner input field.

**Importance**: Critical for capturing barcode scanner output

##### update_raw_scan_display

```python
def update_raw_scan_display(self, text: str)
```

**Description**: Update label showing last scanned barcode.

**Args:**
- `text` (str): Scanned text

##### add_order_to_history

```python
def add_order_to_history(self, order_number: str)
```

**Description**: Add order to scan history table.

**Args:**
- `order_number` (str): Order number to add

**Display**: Adds to top of history table (newest first)

---

### DashboardWidget

**Module**: `dashboard_widget.py`

**Description**: Dashboard widget displaying performance metrics and analytics. Features real-time statistics, time period filtering, and per-client breakdowns.

#### Class Definition

```python
class DashboardWidget(QWidget):
    """
    Dashboard widget displaying performance metrics and analytics.

    Features:
    - Overall statistics (total sessions, orders, items)
    - Per-client analytics
    - Performance metrics (orders/hour, items/hour)
    - Time period selection (7/30/90 days, all time)
    - Auto-refresh every 60 seconds
    """
```

#### Constructor

```python
def __init__(self, profile_manager, stats_manager, parent=None)
```

**Description**: Initialize dashboard widget.

**Args:**
- `profile_manager` (ProfileManager): Profile manager instance
- `stats_manager` (StatisticsManager): Statistics manager instance
- `parent` (QWidget, optional): Parent widget

**UI Components:**
- `period_combo` (QComboBox): Time period selector
- `client_combo` (QComboBox): Client filter
- `total_sessions_card` (MetricCard): Total sessions metric
- `total_orders_card` (MetricCard): Total orders metric
- `total_items_card` (MetricCard): Total items metric
- `avg_orders_card` (MetricCard): Average orders per session
- `avg_items_card` (MetricCard): Average items per session
- `avg_duration_card` (MetricCard): Average session duration
- `orders_per_hour_card` (MetricCard): Orders per hour rate
- `items_per_hour_card` (MetricCard): Items per hour rate
- `refresh_timer` (QTimer): Auto-refresh timer (60s)

#### Public Methods

##### load_clients

```python
def load_clients(self, client_ids: list[str])
```

**Description**: Load available clients into filter combo box.

**Args:**
- `client_ids` (list[str]): List of client IDs

##### refresh

```python
def refresh(self)
```

**Description**: Public method to refresh all metrics.

**Called By**: MainWindow when switching to dashboard view

---

### SessionHistoryWidget

**Module**: `session_history_widget.py`

**Description**: Widget for viewing and searching historical session data. Features advanced filtering, search capabilities, and data export.

#### Class Definition

```python
class SessionHistoryWidget(QWidget):
    """
    Widget for viewing and searching historical session data.

    Features:
    - View completed sessions with detailed metrics
    - Search by session ID, PC name, or date range
    - Export filtered results to Excel/CSV
    - View session details

    Signals:
        session_selected (str, str): Emitted when session is selected
            Args: client_id, session_id
    """
```

#### Constructor

```python
def __init__(self, profile_manager, parent=None)
```

**Description**: Initialize session history widget.

**Args:**
- `profile_manager` (ProfileManager): Profile manager instance
- `parent` (QWidget, optional): Parent widget

**UI Components:**
- `client_combo` (QComboBox): Client filter
- `search_box` (QLineEdit): Text search input
- `date_filter_checkbox` (QCheckBox): Enable date range filter
- `start_date_edit` (QDateEdit): Start date selector
- `end_date_edit` (QDateEdit): End date selector
- `include_incomplete_checkbox` (QCheckBox): Include incomplete sessions
- `table` (QTableWidget): Sessions table
- `refresh_button` (QPushButton): Refresh data button
- `export_button` (QPushButton): Export to Excel button
- `export_csv_button` (QPushButton): Export to CSV button

**Table Columns:**
1. Session ID
2. Client
3. Start Time
4. Duration (min)
5. Total Orders
6. Completed
7. In Progress
8. Items Packed
9. PC Name
10. Status

#### Public Methods

##### load_clients

```python
def load_clients(self, client_ids: list[str])
```

**Description**: Load available clients into filter combo box.

**Args:**
- `client_ids` (list[str]): List of client IDs

##### refresh

```python
def refresh(self)
```

**Description**: Refresh the session list with current filters.

#### Private Methods

##### _load_sessions

```python
def _load_sessions(self)
```

**Description**: Load sessions based on current filters.

**Filtering:**
- Client ID (if selected)
- Date range (if enabled)
- Include incomplete flag

##### _display_sessions

```python
def _display_sessions(self, sessions: list[SessionHistoryRecord])
```

**Description**: Display sessions in the table.

**Args:**
- `sessions` (list[SessionHistoryRecord]): Sessions to display

##### _on_search_changed

```python
def _on_search_changed(self, text: str)
```

**Description**: Handle search text changes.

**Args:**
- `text` (str): Search term

**Search Fields:**
- Session ID
- PC name
- Packing list path

##### _show_session_details

```python
def _show_session_details(self, session: SessionHistoryRecord)
```

**Description**: Show detailed information dialog for a session.

**Args:**
- `session` (SessionHistoryRecord): Session to show details for

##### _export_to_excel

```python
def _export_to_excel(self)
```

**Description**: Export filtered sessions to Excel file.

**File Format**: .xlsx with formatted columns

##### _export_to_csv

```python
def _export_to_csv(self)
```

**Description**: Export filtered sessions to CSV file.

**File Format**: UTF-8 CSV with BOM for Excel compatibility

---

### SessionMonitorWidget

**Module**: `session_monitor_widget.py`

**Description**: Widget for monitoring active sessions across all clients. Shows real-time information about who is working on which sessions.

#### Class Definition

```python
class SessionMonitorWidget(QWidget):
    """
    Widget for monitoring active sessions across all clients.

    Shows a table with:
    - Client ID
    - Session name
    - User name
    - Computer name
    - Lock time
    - Last heartbeat

    Features:
    - Auto-refresh every 30 seconds
    - Manual refresh button
    """
```

#### Constructor

```python
def __init__(self, lock_manager, parent=None)
```

**Description**: Initialize session monitor widget.

**Args:**
- `lock_manager` (SessionLockManager): Lock manager instance
- `parent` (QWidget, optional): Parent widget

**Auto-Refresh**: Timer updates display every 30 seconds

#### Public Methods

##### set_auto_refresh

```python
def set_auto_refresh(self, enabled: bool)
```

**Description**: Enable or disable auto-refresh.

**Args:**
- `enabled` (bool): True to enable, False to disable

---

## UI Dialogs

### ColumnMappingDialog

**Module**: `mapping_dialog.py`

**Description**: Dialog for mapping required columns to columns from imported file. Presented when Excel file doesn't contain standard column names.

#### Class Definition

```python
class ColumnMappingDialog(QDialog):
    """
    Dialog for mapping required columns to columns from an imported file.

    Allows user to manually associate application's required fields
    (e.g., 'Order_Number', 'SKU') with actual column names in their file.
    """
```

#### Constructor

```python
def __init__(self, required_columns: list[str], file_columns: list[str], parent: QWidget = None)
```

**Description**: Initialize column mapping dialog.

**Args:**
- `required_columns` (list[str]): Required column names
- `file_columns` (list[str]): Actual column names from file
- `parent` (QWidget, optional): Parent widget

**UI**: One combo box per required column showing available file columns

#### Public Methods

##### get_mapping

```python
def get_mapping(self) -> dict[str, str]
```

**Description**: Get the final mapping created by user.

**Returns:**
- `dict[str, str]`: Mapping from required columns to file columns

**Example:**
```python
{
    'Order_Number': 'OrderID',
    'SKU': 'ProductCode',
    'Quantity': 'Qty'
}
```

---

### RestoreSessionDialog

**Module**: `restore_session_dialog.py`

**Description**: Dialog for selecting and restoring incomplete sessions. Shows lock status and provides force-release option for stale locks.

#### Class Definition

```python
class RestoreSessionDialog(QDialog):
    """
    Dialog for selecting and restoring incomplete sessions.

    Shows:
    - List of incomplete sessions for client
    - Lock status (active, stale, or available)
    - Computer and user information for locked sessions
    - Force-release option for stale locks
    """
```

#### Constructor

```python
def __init__(self, client_id: str, profile_manager, lock_manager, parent=None)
```

**Description**: Initialize restore session dialog.

**Args:**
- `client_id` (str): Client identifier
- `profile_manager` (ProfileManager): Profile manager instance
- `lock_manager` (SessionLockManager): Lock manager instance
- `parent` (QWidget, optional): Parent widget

**Icons:**
- 🔒 = Active on another PC
- ⚠️ = Stale lock (possible crash)
- 📦 = Available

#### Public Methods

##### get_selected_session

```python
def get_selected_session(self) -> Optional[Path]
```

**Description**: Get the selected session directory.

**Returns:**
- `Path`: Path to selected session, or None if canceled

---

### SKUMappingDialog

**Module**: `sku_mapping_dialog.py`

**Description**: Dialog for managing Barcode-to-SKU mappings. Uses ProfileManager for centralized storage with file locking.

#### Class Definition

```python
class SKUMappingDialog(QDialog):
    """
    Dialog for managing Barcode-to-SKU mappings.

    Features:
    - Table view of current mappings
    - Add, edit, delete operations
    - Reload from server button
    - Centralized storage with file locking
    - Changes synchronized across all PCs
    """
```

#### Constructor

```python
def __init__(self, client_id: str, profile_manager, parent=None)
```

**Description**: Initialize SKU mapping dialog.

**Args:**
- `client_id` (str): Client identifier
- `profile_manager` (ProfileManager): Profile manager instance
- `parent` (QWidget, optional): Parent widget

**Table Columns:**
1. Product Barcode (scanned from product)
2. Internal SKU (used in packing list)

#### Public Methods

##### get_mappings

```python
def get_mappings(self) -> dict[str, str]
```

**Description**: Get the current mappings.

**Returns:**
- `dict[str, str]`: Barcode-to-SKU mapping

---

### PrintDialog

**Module**: `print_dialog.py`

**Description**: Dialog for previewing and printing generated barcode labels. Shows grid preview and provides print button.

#### Class Definition

```python
class PrintDialog(QDialog):
    """
    Dialog for previewing and printing barcode labels.

    Features:
    - Grid preview of all barcodes (3 per row)
    - System print dialog integration
    - Automatic page layout and breaks
    """
```

#### Constructor

```python
def __init__(self, orders_data: dict, parent: QWidget = None)
```

**Description**: Initialize print dialog.

**Args:**
- `orders_data` (dict): Order data from PackerLogic
- `parent` (QWidget, optional): Parent widget

**Layout**: 3 barcodes per row in preview

#### Public Methods

##### print_widget

```python
def print_widget(self)
```

**Description**: Open print dialog and print barcode labels.

**Printer Settings:**
- High resolution (203 DPI)
- Automatic page breaks
- 50pt margins
- Label size: 300x150 points

---

## Data Models

### OrderTableModel

**Module**: `order_table_model.py`

**Description**: Qt table model for displaying order summary data from pandas DataFrame. Provides interface between DataFrame and QTableView.

#### Class Definition

```python
class OrderTableModel(QAbstractTableModel):
    """
    Qt Table Model to display order summary data from a pandas DataFrame.

    Features:
    - Displays DataFrame in QTableView
    - Color-codes completed orders (light green background)
    - Supports programmatic updates
    """
```

#### Constructor

```python
def __init__(self, data: pd.DataFrame, parent: QWidget = None)
```

**Description**: Initialize OrderTableModel.

**Args:**
- `data` (pd.DataFrame): Order summary DataFrame
- `parent` (QWidget, optional): Parent widget

#### Public Methods

##### rowCount

```python
def rowCount(self, parent: QModelIndex = QModelIndex()) -> int
```

**Description**: Get number of rows.

**Args:**
- `parent` (QModelIndex): Parent index

**Returns:**
- `int`: Number of rows in DataFrame

##### columnCount

```python
def columnCount(self, parent: QModelIndex = QModelIndex()) -> int
```

**Description**: Get number of columns.

**Args:**
- `parent` (QModelIndex): Parent index

**Returns:**
- `int`: Number of columns in DataFrame

##### data

```python
def data(self, index: QModelIndex, role: int = Qt.DisplayRole) -> Any
```

**Description**: Get data for a given index and role.

**Args:**
- `index` (QModelIndex): Cell index
- `role` (int): Data role (DisplayRole, BackgroundRole, etc.)

**Returns:**
- `Any`: Data for specified role

**Roles Supported:**
- `Qt.DisplayRole`: Cell text
- `Qt.BackgroundRole`: Light green for completed orders

##### headerData

```python
def headerData(self, section: int, orientation: Qt.Orientation, role: int = Qt.DisplayRole) -> Optional[str]
```

**Description**: Get header data for table.

**Args:**
- `section` (int): Row or column number
- `orientation` (Qt.Orientation): Horizontal or Vertical
- `role` (int): Data role

**Returns:**
- `str`: Column header text

##### setData

```python
def setData(self, index: QModelIndex, value: Any, role: int = Qt.EditRole) -> bool
```

**Description**: Set data for a given index.

**Args:**
- `index` (QModelIndex): Cell index
- `value` (Any): New value
- `role` (int): Edit role

**Returns:**
- `bool`: True if successfully set

##### get_column_index

```python
def get_column_index(self, column_name: str) -> int
```

**Description**: Get numerical index for a column name.

**Args:**
- `column_name` (str): Name of column

**Returns:**
- `int`: Column index, or -1 if not found

---

### CustomFilterProxyModel

**Module**: `custom_filter_proxy_model.py`

**Description**: Custom filter proxy model for advanced multi-column filtering. Enables searching across Order_Number, Status, and SKUs.

#### Class Definition

```python
class CustomFilterProxyModel(QSortFilterProxyModel):
    """
    Custom filter proxy model for advanced, multi-column filtering.

    Features:
    - Search by order number
    - Search by order status
    - Search by SKU (searches all SKUs in order)
    """
```

#### Constructor

```python
def __init__(self, parent: QWidget = None)
```

**Description**: Initialize CustomFilterProxyModel.

**Args:**
- `parent` (QWidget, optional): Parent widget

**Attributes:**
- `_processed_df` (pd.DataFrame): Detailed order data with SKUs
- `search_term` (str): Current search term (lowercase)

#### Public Methods

##### set_processed_df

```python
def set_processed_df(self, df: pd.DataFrame)
```

**Description**: Set DataFrame containing detailed order and SKU information.

**Args:**
- `df` (pd.DataFrame): DataFrame with SKU details

**Purpose**: Enable SKU-based search

##### setFilterFixedString

```python
def setFilterFixedString(self, text: str)
```

**Description**: Set search term and trigger filter invalidation.

**Args:**
- `text` (str): Search string

**Note**: Overrides base class method

##### filterAcceptsRow

```python
def filterAcceptsRow(self, source_row: int, source_parent: QModelIndex) -> bool
```

**Description**: Determine if row should be included in filtered view.

**Args:**
- `source_row` (int): Row number in source model
- `source_parent` (QModelIndex): Parent index

**Returns:**
- `bool`: True if row matches filter

**Filter Logic:**
1. Check order number
2. Check status
3. Check all SKUs associated with order

---

## Utilities

### AppLogger

**Module**: `logger.py`

**Description**: Centralized logging configuration with thread-safety, file rotation, and structured logging.

#### Class Definition

```python
class AppLogger:
    """
    Centralized logging configuration for Packer's Assistant.

    Features:
    - Thread-safe singleton pattern
    - File rotation (10 MB per file, 5 backups)
    - Automatic log cleanup (30 days)
    - Structured logging with extra fields
    - Console and file handlers
    """
```

#### Class Methods

##### get_logger

```python
@classmethod
def get_logger(cls, name: str = None) -> logging.Logger
```

**Description**: Get a logger instance with configuration.

**Args:**
- `name` (str, optional): Logger name (usually `__name__`)

**Returns:**
- `logging.Logger`: Configured logger instance

**Usage:**
```python
from logger import AppLogger

logger = AppLogger.get_logger(__name__)
logger.info("Application started")
logger.error("An error occurred", exc_info=True)
```

**Log Format:**
```
2025-11-03 14:30:00,123 - INFO - main - Application started
```

**Log Location**: `~/.packers_assistant/logs/`

**Log Rotation:**
- Max file size: 10 MB
- Backup count: 5 files
- Automatic cleanup: 30 days

**Extra Fields Support:**
```python
logger.info(
    "Session started",
    extra={
        "client_id": "M",
        "session_id": "2025-11-03_14-30"
    }
)
```

---

### Exceptions

**Module**: `exceptions.py`

**Description**: Custom exception classes for specific error conditions.

#### Exception Classes

##### PackingToolError

```python
class PackingToolError(Exception):
    """Base exception for all Packer's Assistant errors."""
```

**Description**: Base class for all custom exceptions.

**Usage**: Catch all application-specific errors:
```python
try:
    # Application code
    pass
except PackingToolError as e:
    logger.error(f"Application error: {e}")
```

##### NetworkError

```python
class NetworkError(PackingToolError):
    """Raised when file server network issues occur."""
```

**Description**: File server connectivity problems.

**Common Causes:**
- File server offline
- Network cable unplugged
- SMB/CIFS share not accessible
- Drive mapping lost

**Example:**
```python
if not self.file_server_root.exists():
    raise NetworkError(f"Cannot access file server: {self.file_server_root}")
```

##### SessionLockedError

```python
class SessionLockedError(PackingToolError):
    """Raised when attempting to access a locked session."""
```

**Description**: Session is locked by another PC.

**Attributes:**
- `lock_info` (dict): Information about who has the lock

**Example:**
```python
raise SessionLockedError(
    f"Session locked by {lock_info['user_name']} on {lock_info['locked_by']}"
)
```

##### StaleLockError

```python
class StaleLockError(SessionLockedError):
    """Raised when a session has a stale lock (crashed session)."""
```

**Description**: Session lock exists but heartbeat is stale.

**Resolution**: Offer user option to force-release lock

##### ProfileError

```python
class ProfileError(PackingToolError):
    """Raised when client profile operations fail."""
```

**Description**: Issues with client profile management.

**Common Causes:**
- Profile doesn't exist
- Corrupted config.json
- Permission denied

##### ValidationError

```python
class ValidationError(PackingToolError):
    """Raised when input validation fails."""
```

**Description**: Invalid data provided.

**Common Causes:**
- Missing required columns in Excel
- Invalid barcode format
- Corrupted packing list

---

## Document Information

**Version**: 1.0
**Last Updated**: 2025-11-04
**Completeness**: All 19 Python modules documented
**Total Classes**: 25+
**Total Public Methods**: 150+
**Total Private Methods**: 50+

## Quick Reference

### Most Common Workflows

#### Starting a Session
```python
# 1. Initialize managers
profile_manager = ProfileManager("\\\\Server\\Share")
lock_manager = SessionLockManager(profile_manager)
session_manager = SessionManager(profile_manager, lock_manager)

# 2. Start session
session_id = session_manager.start_session("orders.xlsx")

# 3. Initialize packer logic
packer_logic = PackerLogic(
    session_dir=session_manager.current_session_dir,
    profile_manager=profile_manager,
    sku_mapping_manager=sku_mapping_manager
)

# 4. Load and process
packer_logic.load_packing_list_from_file("orders.xlsx")
summary_df = packer_logic.process_data_and_generate_barcodes()
```

#### Processing Scans
```python
# Order barcode scanned
success, msg, items = packer_logic.start_order_packing("ORDER-123")

# SKU barcode scanned
success, msg, packed, required, complete = packer_logic.process_sku_scan("SKU-001")

if complete:
    # Order complete, play victory sound
    play_completion_sound()
```

#### Ending a Session
```python
# 1. Generate completion report
generate_completion_report()

# 2. Record statistics
stats_manager.record_session_completion(
    client_id="M",
    session_id=session_id,
    completed_orders=150,
    total_items=567,
    duration_seconds=4500
)

# 3. Clean up
packer_logic.end_session_cleanup()
session_manager.end_session()
```

### Common Patterns

#### Error Handling
```python
from exceptions import SessionLockedError, NetworkError, ValidationError

try:
    session_id = session_manager.start_session("orders.xlsx")
except SessionLockedError as e:
    show_error_dialog(f"Session is in use: {e}")
except NetworkError as e:
    show_error_dialog(f"File server not accessible: {e}")
except ValidationError as e:
    show_error_dialog(f"Invalid packing list: {e}")
except Exception as e:
    logger.error(f"Unexpected error: {e}", exc_info=True)
    show_error_dialog(f"An unexpected error occurred: {e}")
```

#### Logging
```python
from logger import AppLogger

logger = AppLogger.get_logger(__name__)

# Basic logging
logger.info("Session started")
logger.warning("SKU mapping not found, using default")
logger.error("Failed to save state", exc_info=True)

# Structured logging with extra fields
logger.info(
    "Order completed",
    extra={
        "client_id": "M",
        "order_number": "ORDER-123",
        "items_packed": 15
    }
)
```

#### Signal/Slot Connections
```python
# Connect signals
packer_logic.item_packed.connect(self._on_item_packed)
packer_logic.order_completed.connect(self._on_order_completed)
packer_logic.error_occurred.connect(self._on_error)

# Emit signals
self.barcode_scanned.emit(barcode_text)
self.session_started.emit(session_id)
```

---

**End of API Reference**
